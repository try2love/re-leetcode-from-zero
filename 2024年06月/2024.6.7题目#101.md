# 101对称二叉树

[101. 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/description/)

## 题目描述

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

 

**示例 1：**

![img](./assets/1698026966-JDYPDU-image.png)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

![img](./assets/1698027008-nPFLbM-image.png)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

 

**提示：**

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`

 

**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？

## 我的C++解法

刚开始的思路是递归，如果左一直等于右则为true

后面发现这个思路是错误的，目标是判断是否轴对称。

再后来想法是直接反转二叉树，如果反转前后不变，则说明是对称二叉树

不得不说这个题是真的有难度

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* reverse_tree(TreeNode* node){
        if(!node)   return node;
        swap(node->left,node->right);
        if(node->left)  reverse_tree(node->left);
        if(node->right) reverse_tree(node->right);
        return node;
    }
    // void dfs(TreeNode* node){
    //     if(!node)   return;
    //     if(node->left)  dfs(node->left);
    //     if(node->right) dfs(node->right);
    // }
    bool isSymmetric(TreeNode* root) {
        // 反转之后和本身相等
        if(!root)   return true;
        TreeNode* before = root;
        root = reverse_tree(root);
        // 下面比较两棵树是否相等即可
        queue<TreeNode*> a;
        queue<TreeNode*> b;
        a.push(before);
        b.push(root);
        while(a.size()==b.size() && !a.empty()){
            TreeNode* top1 = a.front();
            TreeNode* top2 = b.front();
            a.pop();
            b.pop();
            if(top1 != top2)    return false;
            else{
                if(top1->left){
                    a.push(top1->left);
                    b.push(top2->left);
                }
                if(top1->right){
                    a.push(top1->right);
                    b.push(top2->right);
                }
            }
        }
        if(a.size()==0 && b.size()==0)   return true;
        // cout<<"1"<<endl;
        return false;
    }
};
```

结果错误

## C++参考答案

### 递归

如果同时满足下面的条件，两个树互为镜像：

- 它们的两个根结点具有相同的值
- 每个树的右子树都与另一个树的左子树镜像对称

我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p指针和 q 指针一开始都指向这棵树的根，随后 p右移时，q 左移，p 左移时，q右移。每次检查当前 p 和 q节点的值是否相等，如果相等再判断左右子树是否对称。

```cpp
class Solution {
public:
    bool check(TreeNode *p, TreeNode *q) {
        if (!p && !q) return true;
        if (!p || !q) return false;
        return p->val == q->val && check(p->left, q->right) && check(p->right, q->left);
    }

    bool isSymmetric(TreeNode* root) {
        return check(root, root);
    }
};
```

### 迭代

引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。

```cpp
class Solution {
public:
    bool check(TreeNode *u, TreeNode *v) {
        queue <TreeNode*> q;
        q.push(u); q.push(v);
        while (!q.empty()) {
            u = q.front(); q.pop();
            v = q.front(); q.pop();
            if (!u && !v) continue;
            if ((!u || !v) || (u->val != v->val)) return false;

            q.push(u->left); 
            q.push(v->right);

            q.push(u->right); 
            q.push(v->left);
        }
        return true;
    }

    bool isSymmetric(TreeNode* root) {
        return check(root, root);
    }
};
```



## C++收获



## 我的python解答

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        def reverse_tree(node:'TreeNode'):
            if not node:    return node
            node.left, node.right = node.right, node.left
            # print("当前交换左右子树的节点信息",node)
            reverse_tree(node.left)
            reverse_tree(node.right)
            return node
        tmp = deepcopy(root)
        # print("交换前：",root)
        # print("反转树：",reverse_tree(root))
        # print("交换后：",root)
        root = reverse_tree(root)
        a = [tmp]
        b = [root]
        while len(a)==len(b) and len(a)!=0:
            top1 = a[0]
            top2 = b[0]
            del a[0]
            del b[0]
            print("top1:",top1)
            print("top2:",top2)
            if top1!=top2:  return False
            if top1.left:
                a.append(top1.left)
                b.append(top2.left)
            if top1.right:
                a.append(top1.right)
                b.append(top2.right)
        if len(a)==0 and len(b)==0: return True
        return False
```

去他妈的。错了

## python参考答案



## python收获