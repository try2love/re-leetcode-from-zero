# 96不同的二叉搜索树（中等）

[96. 不同的二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-binary-search-trees/description/)

## 题目描述

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```

 

**提示：**

- `1 <= n <= 19`

## 我的C++解法

```cpp
class Solution {
public:
    int numTrees(int n) {
        // 二叉搜索树：中序有序
        // 使用动态规划，dp[i]表示由i个节点组成的二叉搜索树的个数
        // 新节点的插入位置：右上和右下
        // 对于一条右侧直链，插入位点个数=2+（n-2）=n 是数学推导出来的，后面的n-2是插入中间间隔
        vector<int> dp(n+1);
        dp[0] = 0;
        dp[1] = 1;
        for(int i=2;i<=n;i++){
            dp[i] = 2*(dp[i-1]-1) + i;
        }
        return dp[n];
    }
};
```

从4开始就报错了。

然后我开始尝试逐个分析右下链条

探究发现，对于n=1，可以认为是1个（长度为1的右链条），加入新元素后，得到的是1个长2的和1个长1的右链条，总和为2

对于n=2，已知有1个长2和1个长1。一个长2得到的是1个长3，1个长2，1个长1的右链条，得到个数为1$\times$(2+1)=3；对于1个长1，可以得到1$\times$(1+1)=2，总和为5。

对于n=3，由n=2的分析可知，1条长3，2条长2，2条长1，结果：1$\times$(3+1) + 2$\times$(2+1) + 2$\times$(1+1) = 4+6+4 = 14

总的来说，对于长为m的右链条，新加入一个节点后满足题意的解的个数为m，得到的结果：1条m，1条m-1，$\dots$1条1

同理，对于总节点数为i的节点来说：前一步得到的是1个长i-1；。。。知道怎么搞，但是怎么描述不清

```cpp
class Solution {
public:
    int numTrees(int n) {
        // 二叉搜索树：中序有序
        vector<int> dp(n+1);// 存储右侧直链的数目
        dp[0] = 0;// 长度为0的直链
        dp[1] = 1;// 长度为1的直链
        for(int i=2;i<=n;i++){
            dp[i] = 1;
            for(int j=i-1;j>0;j--){
                dp[j] = dp[j+1]+dp[j-1];
            }
        }
        int sum=0;
        for(int x:dp){
            sum += x;
        }
        return sum;
    }
};
```

结果：

![image-20240811104241864](./assets/image-20240811104241864.png)

## C++参考答案

n为1的时候有一棵树，n为2有两棵树，这个是很直观的。

![96.不同的二叉搜索树](./assets/20210107093106367.png)

来看看n为3的时候，有哪几种情况。

<img src="./assets/20210107093129889.png" alt="96.不同的二叉搜索树1"  />

当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和 n 为2的时候两棵树的布局是一样的啊！

（可能有同学问了，这布局不一样啊，节点数值都不一样。别忘了我们就是求不同树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异）

当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局也是一样的啊！

当2为头结点的时候，其左右子树都只有一个节点，布局是不是和n为1的时候只有一棵树的布局也是一样的啊！

发现到这里，其实我们就找到了重叠子问题了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。

思考到这里，这道题目就有眉目了。

dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

有2个元素的搜索树数量就是dp[2]。

有1个元素的搜索树数量就是dp[1]。

有0个元素的搜索树数量就是dp[0]。

所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]

如图所示：

![96.不同的二叉搜索树2](./assets/20210107093226241.png)

此时我们已经找到递推关系了，那么可以用动规五部曲再系统分析一遍。

- 确定dp数组（dp table）以及下标的含义

**dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。

也可以理解是i个不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。

以下分析如果想不清楚，就来回想一下dp[i]的定义

- 确定递推公式

在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]

j相当于是头结点的元素，从1遍历到i为止。

所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量

- dp数组如何初始化

初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。

那么dp[0]应该是多少呢？

从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。

从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。

所以初始化dp[0] = 1

- 确定遍历顺序

首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。

那么遍历i里面每一个数作为头结点的状态，用j来遍历。

代码如下：

```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
        dp[i] += dp[j - 1] * dp[i - j];
    }
}
```

- 举例推导dp数组

n为5时候的dp数组状态如图：

![96.不同的二叉搜索树3](./assets/20210107093253987.png)

当然如果自己画图举例的话，基本举例到n为3就可以了，n为4的时候，画图已经比较麻烦了。

**我这里列到了n为5的情况，是为了方便大家 debug代码的时候，把dp数组打出来，看看哪里有问题**。

综上分析完毕，C++代码如下：

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(n)$

大家应该发现了，我们分析了这么多，最后代码却如此简单！

结果：

![image-20240811105259526](./assets/image-20240811105259526.png)

## C++收获



## 我的python解答

```python
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0]*(n+1)
        dp[0] = 0
        dp[1] = 1
        for i in range(2,n+1):
            dp[i] = 1
            for j in range(i-1,0,-1):
                dp[j] = dp[j+1] + dp[j-1]
        return sum(dp)
```

结果：

![image-20240811104450102](./assets/image-20240811104450102.png)

## python参考答案

```python
class Solution:
    def numTrees(self, n: int) -> int:
        dp = [0] * (n + 1)  # 创建一个长度为n+1的数组，初始化为0
        dp[0] = 1  # 当n为0时，只有一种情况，即空树，所以dp[0] = 1
        for i in range(1, n + 1):  # 遍历从1到n的每个数字
            for j in range(1, i + 1):  # 对于每个数字i，计算以i为根节点的二叉搜索树的数量
                dp[i] += dp[j - 1] * dp[i - j]  # 利用动态规划的思想，累加左子树和右子树的组合数量
        return dp[n]  # 返回以1到n为节点的二叉搜索树的总数量
```

结果：

![image-20240811105232121](./assets/image-20240811105232121.png)

## python收获